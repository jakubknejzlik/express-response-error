// Generated by CoffeeScript 1.10.0
(function() {
  var ResponseError, curlify, responses,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  curlify = require('request-as-curl');

  ResponseError = (function(superClass) {
    extend(ResponseError, superClass);

    function ResponseError(message1, code) {
      this.message = message1;
      this.code = code != null ? code : 400;
      ResponseError.__super__.constructor.apply(this, arguments);
    }

    ResponseError.prototype.toString = function() {
      return "ResponseError (" + this.code + "): " + this.message;
    };

    return ResponseError;

  })(Error);

  responses = {
    error: function(message, statusCode) {
      var error, errorMessage, options, responseError;
      if (statusCode == null) {
        statusCode = 400;
      }
      options = this.req._responseErrorOptions || {};
      error = message instanceof Error ? message : new Error(message);
      errorMessage = error.message;
      if (options.translate === 'i18n' && this.__) {
        errorMessage = this.__(errorMessage);
      } else if (typeof options.translate === 'function') {
        errorMessage = options.translate(errorMessage);
      }
      responseError = new ResponseError(errorMessage, statusCode);
      if (process.env.NODE_ENV !== 'production' || this.req.query.debug || options.stackLogging) {
        responseError.stack = error.stack;
      }
      if (process.env.RESPONSE_ERROR_LOGGING || options.logging) {
        console.error(responseError.toString());
      }
      throw responseError;
    },
    unauthorized: function(message) {
      return this.error(message, 401);
    },
    paymentRequired: function(message) {
      return this.error(message, 402);
    },
    forbidden: function(message) {
      return this.error(message, 403);
    },
    notFound: function(message) {
      return this.error(message, 404);
    },
    methodNotAllowed: function(message) {
      return this.error(message, 405);
    },
    notAcceptable: function(message) {
      return this.error(message, 406);
    },
    proxyAuthenticationRequired: function(message) {
      return this.error(message, 407);
    },
    requestTimeout: function(message) {
      return this.error(message, 408);
    },
    conflict: function(message) {
      return this.error(message, 409);
    },
    gone: function(message) {
      return this.error(message, 410);
    },
    lengthRequired: function(message) {
      return this.error(message, 411);
    },
    preconditionFailed: function(message) {
      return this.error(message, 412);
    },
    requestEntityTooLarge: function(message) {
      return this.error(message, 413);
    },
    requestURITooLong: function(message) {
      return this.error(message, 414);
    },
    unsuportedMediaType: function(message) {
      return this.error(message, 415);
    },
    requestedRangeNotSatisfiable: function(message) {
      return this.error(message, 416);
    },
    expectationFailed: function(message) {
      return this.error(message, 417);
    },
    internalServerError: function(message) {
      return this.error(message, 500);
    },
    notImplemented: function(message) {
      return this.error(message, 501);
    },
    badGateway: function(message) {
      return this.error(message, 502);
    },
    serviceUnavailable: function(message) {
      return this.error(message, 503);
    },
    gatewayTimeout: function(message) {
      return this.error(message, 504);
    },
    httpVersionNotSupported: function(message) {
      return this.error(message, 505);
    }
  };

  module.exports = function(options) {
    if (options == null) {
      options = {};
    }
    return function(req, res, next) {
      var name, responseHandler;
      req._responseErrorOptions = options;
      for (name in responses) {
        responseHandler = responses[name];
        res[name] = responseHandler;
      }
      return next();
    };
  };

  module.exports.ResponseError = ResponseError;

}).call(this);
